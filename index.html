<!--Aqui realizaremos o desenvolvimento do nosso jogo-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Arrocha Árabe: Asteroides></title>
    <style></style>

</head>

<body>
    <canvas id="Canvasdojogo" width="800" height="600"></canvas>
    <script>
     //Aqui definimos as funções que serão utilizadas ao longo do código   
     const FPS = 30
     const TAMANHO_DA_NAVE =  30
     const IMPULSO_DA_NAVE  = 5
     const VELOCIDADE_DE_ROTAÇÃO = 180
     const FRICÇÃO = 0.7
     const VELOCIDADE_DOS_ASTEROIDES = 50
     const TAMANHO_DOS_ASTEROIDES = 100
     const VÉRTICE_DO_ASTEROIDE = 10
     const canv = document.getElementById("Canvasdojogo");
     const contexto = canv.getContext("2d")

     //Aqui, criamos um registro com as informações da nave, dando o Object.freeze afim de garantir a imutabilidade dela
     const nave = Object.freeze( 
        {
          x: canv.width / 2, 
          y: canv.height / 2, //essas duas estão sendo utilizadas para fazer a nave começar do meio da tela, por meio de informações das coordenadas x e y
          raio: TAMANHO_DA_NAVE / 2,
          ângulo: 90 / 180 * Math.PI, // converte para radianos 
          rotação: 0,
          impulsionando: false,
          impulso: Object.freeze({
                x: 0,
                y: 0
           })  

        })
     
    
//Aqui, criamos uma cópia do registro, para podermos alterar valores e, ainda assim, garantir a imutabilidade do registro original
   const novaNave = {
  ...nave,
  impulso: {...nave.impulso}
   }

   //Aqui, realizamos os comandos e o código para os eventos do clique de teclas no teclado, para fazer a nave se movimentat pelo mapa
    const keyDown = (/** @type {KeyboardEvent} */ evento) => {  // o keycode armazena um número que representa a tecla que foi pressionada
     switch(evento.keyCode){
          case 37: //37 representa a seta para a esquerda(objetivo: rotacionar para a esquerda)
            novaNave.rotação = VELOCIDADE_DE_ROTAÇÃO / 180 * Math.PI / FPS 
            break;
          case 38: //representa a tecla para cima(objetivo: mover a nave para frente) 
           novaNave.impulsionando = true
            break;  
          case 39: //representa a seta para a esquerda(objetivo: rotacionar para a direita)
            novaNave.rotação = -VELOCIDADE_DE_ROTAÇÃO / 180 * Math.PI / FPS
            break; 

            }  
        }
    const keyUp = (/** @type {KeyboardEvent} */evento) => {  // o keycode armazena um número que representa a tecla que foi pressionada
        switch(evento.keyCode) /**uma série de perguntas do tipo if/else*/{
          case 37: //37 representa a seta para a esquerda(objetivo: parar de rotacionar)
            novaNave.rotação = 0; 
            break;
          case 38: //representa a tecla para cima(objetivo: mover a nave para frente) 
            novaNave.impulsionando = false
            break;  
          case 39: //representa a seta para a esquerda(objetivo: parar de rotacionar)
            novaNave.rotação = 0;
            break; 
                
               
            }  
        }
        
        
     document.addEventListener("keydown", keyDown); //keydow vai identificar que alguma teclado de teclado está sendo pressionada
     document.addEventListener("keyup", keyUp);
     //Asteroides

     const asteroideXD = (x,y) => Object.freeze({
        x: x,
        y: y,
        xv: Math.random() * VELOCIDADE_DOS_ASTEROIDES / FPS * (Math.random() < 0.5? 1 : -1),
        yv: Math.random() * VELOCIDADE_DOS_ASTEROIDES / FPS * (Math.random() < 0.5? 1 : -1),
        raio: TAMANHO_DOS_ASTEROIDES / 2,
        ângulo: Math.random() * Math.PI * 2,
        vértices: Math.floor(Math.random() * (VÉRTICE_DO_ASTEROIDE + 1) + VÉRTICE_DO_ASTEROIDE / 2),
        curvaturas: []
        })

        const novo_asteroide2 = {...asteroideXD} 

     //const novo_asteroideXD = (a,b) => Object.freeze({
        //x:a,
        //y:b,
        //xv: Math.random() * VELOCIDADE_DOS_ASTEROIDES / FPS * (Math.random() < 0.5? 1 : -1),
        //yv: Math.random() * VELOCIDADE_DOS_ASTEROIDES / FPS * (Math.random() < 0.5? 1 : -1),
        //raio: TAMANHO_DOS_ASTEROIDES / 2,
        //ângulo: Math.random() * Math.PI * 2,
        //vértices: Math.floor(Math.random() * (VÉRTICE_DO_ASTEROIDE + 1) + VÉRTICE_DO_ASTEROIDE / 2),
        //curvaturas: []
        //})


    const gerarPosicaoAleatoria = (canvas) => ({
            //meio que canvas seria minemonico como argumento arbitrario nesse caso
            //porque se refere ao canvas usado lá em cima
            x: Math.floor(Math.random() * canvas.width), //gera um x do maximo ao minimo da tela, multiplicando o valor da tela por algo netre 0 e 1
            y: Math.floor(Math.random() * canvas.height) //mesma coisa só que pra y
        })


        //como é uma posição aleatória seria complicado se surgisse direto na nave
        //então é bom definir uma distância segura calculando a distância entre os dois pontos
        const verificar_posicao_segura = (nave) => (pedra) => {
            if ((Math.sqrt((pedra.x-nave.x)**2 + (pedra.y-nave.y)**2) >= 225)) //225 ou mais é a distancia segura
            {return true}
            else {return false}
             //se cumprir os pre requisitos retorna true, se não false 
        }


        //função que gera uma posição válida usando recursão
        //canvas é minemonico pelo argumento anterior

         const gerarPosicaoValida = (nave, canvas) => {
            const posicao = gerarPosicaoAleatoria(canvas) //posicao é registro com coordenadas x e y, ele gera uma posiçãp
            if ((verificar_posicao_segura(nave)(posicao))===true) { //testa se a posição é válida
                return posicao //se a posição na constante for segura ele retorna True e gera a posicao, assim se for válido a função acaba
            } else {
            return gerarPosicaoValida(nave, canvas) //se nao repete a funcao em busca de uma posicao valida até achar uma posição valida
            //tava dando erro sem if else e return então essas coisas foram colocadas
        }
    }

        //função para criar asteroides baseada na posição válida
        const criarAsteroide = (nave, canvas) => {
            const posicaoValida = gerarPosicaoValida(nave, canvas)
            return asteroideXD(posicaoValida.x,posicaoValida.y)
        }



        //função que cria a lista de asteroides de forma recursiva
         const criarListaAsteroides = (nave, canvas, quantidade) => {
            if (quantidade <= 0) {
                return []
            }
            else {return [
                criarAsteroide(nave, canvas),
                ...criarListaAsteroides(nave, canvas, quantidade - 1)
            ]}
        }
    gerarPosicaoAleatoria(canv)
         //Criando a constante na qual o jogo irá ser focado, que realmente fará o jogo acontecer
    const update = () => {
        //Desenhando o fundo do jogo
         contexto.fillStyle = "black";
         contexto.fillRect(0, 0, canv.width, canv.height)

         //Desenhando a nave(Em formato triângular)
         contexto.strokeStyle = "red";
         contexto.lineWidth = TAMANHO_DA_NAVE / 20,
         contexto.beginPath()
         contexto.moveTo(
            novaNave.x + 4/3 * novaNave.raio * Math.cos(novaNave.ângulo),
            novaNave.y - 4/3 * novaNave.raio * Math.sin(novaNave.ângulo)

         )
         contexto.lineTo(
            novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) + Math.sin(novaNave.ângulo)), //Traseira Esquerda da Nave
            novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) - Math.cos(novaNave.ângulo))
        )
         contexto.lineTo(
            novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) - Math.sin(novaNave.ângulo)), //Traseira Direita da Nave
            novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) + Math.cos(novaNave.ângulo))
        )    
         contexto.closePath()
         contexto.stroke()

        //Impulsionando a nave

        //Aqui, criamos as funções de soma e subtração para podermos trabalhar com a rotação e movimentação da nave de maneira funcional, por meio de listas
        const soma = (lista) => lista[0] + lista[1]
        const subtração = (lista) => lista [0] - lista[1]
        lista_para_o_impulso_x = [novaNave.impulso.x, IMPULSO_DA_NAVE * Math.cos(novaNave.ângulo) / FPS] 
        lista_para_o_impulso_y = [novaNave.impulso.y, IMPULSO_DA_NAVE * Math.sin(novaNave.ângulo) / FPS]
        lista_para_a_fricção_x = [novaNave.impulso.x, FRICÇÃO * novaNave.impulso.x / FPS] 
        lista_para_a_fricção_y = [novaNave.impulso.y, FRICÇÃO * novaNave.impulso.y / FPS]
        
        //Impulso da nave 
        if (novaNave.impulsionando) {
                novaNave.impulso.x = soma(lista_para_o_impulso_x) ;
                novaNave.impulso.y = subtração(lista_para_o_impulso_y);
                
                contexto.fillStyle = "yellow";
                contexto.strokeStyle = "red"; //pode ser interpretado como "escolher a cor da caneta que será utulizada para desenhar a nave"
                contexto.lineWidth = TAMANHO_DA_NAVE / 10, //define a espessura das linhas
                contexto.beginPath();  // seria basicamente "começar um novo desenho", você tira a ponta da caneta do papel e coloca em um lugar novo para começar uma nova forma
                contexto.moveTo( //foguete esquerdo
                    novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) + 0.5* Math.sin(novaNave.ângulo)), 
                    novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) - 0.5*Math.cos(novaNave.ângulo))
               ); // levantar a ponta do lápis e levar ela a um novo local
                contexto.lineTo( // foguete central atrás da nave
                    novaNave.x - novaNave.raio * (6/3 *Math.cos(novaNave.ângulo) ), //Traseira Esquerda da Nave
                    novaNave.y + novaNave.raio * (6/3 *Math.sin(novaNave.ângulo) )
               )
                contexto.lineTo( //foguete direito
                    novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) - 0.5*Math.sin(novaNave.ângulo)), //Traseira Direita da Nave
                    novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) + 0.5* Math.cos(novaNave.ângulo))
               );
                


                contexto.closePath()
                contexto.fill()
                contexto.stroke()

         } else {
                novaNave.impulso.x = subtração(lista_para_a_fricção_x)
                novaNave.impulso.y = subtração(lista_para_a_fricção_y)
          }


        //Centro do Triângulo(será usado um ponto para marcar o centro)
        contexto.fillStyle = "red"
        contexto.fillRect(novaNave.x - 1, novaNave.y - 1, 2,2) 

        
        //Rotacionando a nave
        
        lista_ângulo_e_rotação = [novaNave.ângulo,novaNave.rotação]
        

        novaNave.ângulo = soma(lista_ângulo_e_rotação)


        //Movendo a nave
        lista_x_e_impulso= [novaNave.x,novaNave.impulso.x]
        lista_y_e_impulso = [novaNave.y,novaNave.impulso.y]

        novaNave.x = soma(lista_x_e_impulso)
        novaNave.y = soma(lista_y_e_impulso)

           //Limitando tela, impedindo a nave de sumir, fazendo ela reaparecer nos outros lados
          if (novaNave.x < 0 - novaNave.raio) {
              novaNave.x = canv.width + novaNave.raio;
          } else if (novaNave.x > canv.width + novaNave.raio) {
              novaNave.x = 0 - novaNave.raio 
         }
         if (novaNave.y < 0 - novaNave.raio) {
              novaNave.y = canv.height + novaNave.raio
          } else if (novaNave.y > canv.height + novaNave.raio) {
            novaNave.y = 0 - novaNave.raio 
          }
        //Desenhando os asteroides
        
        const Desenho_dos_asteroides = (lista) => {  //6=quantidade
           contexto.strokeStyle = "white"
            contexto.lineWidth = TAMANHO_DA_NAVE / 15
            contexto.beginPath()
            contexto.moveTo(
                lista.x + lista.raio * lista.curvaturas * Math.cos(lista.ângulo),
                lista.y + lista.raio * lista.curvaturas * Math.sin(lista.ângulo),
            )
            contexto.lineTo(
                lista.x - lista.raio * (2/3 *Math.cos(lista.ângulo) + Math.sin(lista.ângulo)), //Traseira Esquerda da Nave
                lista.y + lista.raio * (2/3 *Math.sin(lista.ângulo) - Math.cos(lista.ângulo))
            )
            contexto.lineTo(
                lista.x - lista.raio * (2/3 *Math.cos(lista.ângulo) - Math.sin(lista.ângulo)), //Traseira Direita da Nave
                  lista.y + lista.raio * (2/3 *Math.sin(lista.ângulo) + Math.cos(lista.ângulo))
            )      
            contexto.closePath()
            contexto.stroke()
        }
    
       
        const lista_de_asteroide = criarListaAsteroides(novaNave, canv, 6)
        lista_de_asteroide.forEach(novo_asteroide2 => {
            Desenho_dos_asteroides(novo_asteroide2)
        }) 

        

        
       
    }    

    //Irá executar a função update em um intervalo de 1000/FPS  milissegundos, fazendo com que o jogo ocorra
    setInterval(update, 1000 / FPS);

    

    </script>
</body>

</html>
