<!--Aqui realizaremos o desenvolvimento do nosso jogo-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Arrocha Árabe: Asteroides></title>
    <style></style>

</head>

<body>
    
   
    <canvas id="Canvasdojogo" width="800" height="600"></canvas>
    <script>
     //Aqui definimos as funções que serão utilizadas ao longo do código   
     const FPS = 30
     const TAMANHO_DA_NAVE =  30
     const IMPULSO_DA_NAVE  = 5
     const VELOCIDADE_DE_ROTAÇÃO = 180
     const FRICÇÃO = 0.7

     const canv = document.getElementById("Canvasdojogo");
     const contexto = canv.getContext("2d")

     //Aqui, criamos um registro com as informações da nave, dando o Object.freeze afim de garantir a imutabilidade dela
     const nave = Object.freeze( 
        {
          x: canv.width / 2, 
          y: canv.height / 2, //essas duas estão sendo utilizadas para fazer a nave começar do meio da tela, por meio de informações das coordenadas x e y
          raio: TAMANHO_DA_NAVE / 2,
          ângulo: 90 / 180 * Math.PI, // converte para radianos 
          rotação: 0,
          impulsionando: false,
          impulso: Object.freeze({
                x: 0,
                y: 0
           })  

        })
    
//Aqui, criamos uma cópia do registro, para podermos alterar valores e, ainda assim, garantir a imutabilidade do registro original
   const novaNave = {
  ...nave,
  impulso: {...nave.impulso}
   }

   //Aqui, realizamos os comandos e o código para os eventos do clique de teclas no teclado, para fazer a nave se movimentat pelo mapa
    const keyDown = (/** @type {KeyboardEvent} */ evento) => {  // o keycode armazena um número que representa a tecla que foi pressionada
     switch(evento.keyCode){
          case 37: //37 representa a seta para a esquerda(objetivo: rotacionar para a esquerda)
            novaNave.rotação = VELOCIDADE_DE_ROTAÇÃO / 180 * Math.PI / FPS 
            break;
          case 38: //representa a tecla para cima(objetivo: mover a nave para frente) 
           novaNave.impulsionando = true
            break;  
          case 39: //representa a seta para a esquerda(objetivo: rotacionar para a direita)
            novaNave.rotação = -VELOCIDADE_DE_ROTAÇÃO / 180 * Math.PI / FPS
            break; 

            }  
        }
    const keyUp = (/** @type {KeyboardEvent} */evento) => {  // o keycode armazena um número que representa a tecla que foi pressionada
        switch(evento.keyCode) /**uma série de perguntas do tipo if/else*/{
          case 37: //37 representa a seta para a esquerda(objetivo: parar de rotacionar)
            novaNave.rotação = 0; 
            break;
          case 38: //representa a tecla para cima(objetivo: mover a nave para frente) 
            novaNave.impulsionando = false
            break;  
          case 39: //representa a seta para a esquerda(objetivo: parar de rotacionar)
            novaNave.rotação = 0;
            break; 
                
               
            }  
        }
        
        
     document.addEventListener("keydown", keyDown); //keydow vai identificar que alguma teclado de teclado está sendo pressionada
     document.addEventListener("keyup", keyUp);

         //Criando a constante na qual o jogo irá ser focado, que realmente fará o jogo acontecer
    const update = () => {
        //Desenhando o fundo do jogo
         contexto.fillStyle = "black";
         contexto.fillRect(0, 0, canv.width, canv.height);

         //Desenhando a nave(Em formato triângular)
         contexto.strokeStyle = "red";
         contexto.lineWidth = TAMANHO_DA_NAVE / 20,
         contexto.beginPath();
         contexto.moveTo(
            novaNave.x + 4/3 * novaNave.raio * Math.cos(novaNave.ângulo),
            novaNave.y - 4/3 * novaNave.raio * Math.sin(novaNave.ângulo)

         )
         contexto.lineTo(
            novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) + Math.sin(novaNave.ângulo)), //Traseira Esquerda da Nave
            novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) - Math.cos(novaNave.ângulo))
        )
         contexto.lineTo(
            novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) - Math.sin(novaNave.ângulo)), //Traseira Direita da Nave
            novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) + Math.cos(novaNave.ângulo))
        )    
         contexto.closePath();
         contexto.stroke();

        //Impulsionando a nave

        //Aqui, criamos as funções de soma e subtração para podermos trabalhar com a rotação e movimentação da nave de maneira funcional, por meio de listas
        const soma = (lista) => lista[0] + lista[1]
        const subtração = (lista) => lista [0] - lista[1]
        lista_para_o_impulso_x = [novaNave.impulso.x, IMPULSO_DA_NAVE * Math.cos(novaNave.a) / FPS] 
        lista_para_o_impulso_y = [novaNave.impulso.y, IMPULSO_DA_NAVE * Math.sin(novaNave.a) / FPS]
        lista_para_a_fricção_x = [novaNave.impulso.x, FRICÇÃO * novaNave.impulso.x / FPS] 
        lista_para_a_fricção_y = [novaNave.impulso.y, FRICÇÃO * novaNave.impulso.y / FPS]
        
        //Impulso da nave 
        if (novaNave.impulsionando) {
                novaNave.impulso.x = soma(lista_para_o_impulso_x) ;
                novaNave.impulso.y = subtração(lista_para_o_impulso_y);
                
                contexto.fillStyle = "yellow";
                contexto.strokeStyle = "red"; //pode ser interpretado como "escolher a cor da caneta que será utulizada para desenhar a nave"
                contexto.lineWidth = TAMANHO_DA_NAVE / 10, //define a espessura das linhas
                contexto.beginPath();  // seria basicamente "começar um novo desenho", você tira a ponta da caneta do papel e coloca em um lugar novo para começar uma nova forma
                contexto.moveTo( //foguete esquerdo
                    novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.a) + 0.5* Math.sin(novaNave.a)), 
                    novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.a) - 0.5*Math.cos(novaNave.a))
               ); // levantar a ponta do lápis e levar ela a um novo local
                contexto.lineTo( // foguete central atrás da nave
                    novaNave.x - novaNave.raio * (6/3 *Math.cos(novaNave.a) ), //Traseira Esquerda da Nave
                    novaNave.y + novaNave.raio * (6/3 *Math.sin(novaNave.a) )
               )
                contexto.lineTo( //foguete direito
                    novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.a) - 0.5*Math.sin(novaNave.a)), //Traseira Direita da Nave
                    novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.a) + 0.5* Math.cos(novaNave.a))
               );
                


                contexto.closePath();
                contexto.fill();
                contexto.stroke(); 

         } else {
                novaNave.impulso.x = subtração(lista_para_a_fricção_x)
                novaNave.impulso.y = subtração(lista_para_a_fricção_y)
          }


        //Centro do Triângulo(será usado um ponto para marcar o centro)
        contexto.fillStyle = "red"
        contexto.fillRect(novaNave.x - 1, novaNave.y - 1, 2,2) 

        
        //Rotacionando a nave
        
        lista_ângulo_e_rotação = [novaNave.a,novaNave.rotação]
        

        novaNave.a = soma(lista_ângulo_e_rotação)


        //Movendo a nave
        lista_x_e_impulso= [novaNave.x,novaNave.impulso.x]
        lista_y_e_impulso = [novaNave.y,novaNave.impulso.y]

        novaNave.x = soma(lista_x_e_impulso)
        novaNave.y = soma(lista_y_e_impulso)


    }
  

    //Irá executar a função update em um intervalo de 1000/FPS  milissegundos, fazendo com que o jogo ocorra
    setInterval(update, 1000 / FPS);

    </script>
</body>

</html>