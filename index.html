<!--Aqui realizaremos o desenvolvimento do nosso jogo-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Arrocha Árabe: Asteroides></title>
    <style></style>

</head>

<body>
    <canvas id="Canvasdojogo" width="850" height="600"></canvas>
    <audio id="Música de fundo" autoplay loop>
      <source src="Grass Skirt Chase 1 Hour (PERFECT LOOP).mp3" type="audio/mpeg">
      <source src="Grass Skirt Chase 1 Hour (PERFECT LOOP).mp3" type="audio/ogg">
     
    </audio>
    <script>

        
    //O jogo é um testa habilidades de concentração, coordenação, foco, estratégia e memória



     //Aqui definimos as funções que serão utilizadas ao longo do código   
     const FPS = 30
     const TAMANHO_DA_NAVE =  30
     const IMPULSO_DA_NAVE  = 5
     const VELOCIDADE_DE_ROTAÇÃO = 180
     const FRICÇÃO = 0.7
     const VELOCIDADE_DOS_ASTEROIDES = 152 
     const TAMANHO_DOS_ASTEROIDES = 100
     const VÉRTICE_DO_ASTEROIDE = 10
     const TEMPO_DE_BLINK = 0.1 
     const TEMPO_DE_EXPLOSÃO_DA_NAVE = 0.9
     const TEMPO_DE_INVULNERABILIDADE = 3 
     const MOSTRAR_COLISÃO = false
     const canv = document.getElementById("Canvasdojogo");
     const contexto = canv.getContext("2d")
     const audio = document.getElementById("Música de fundo")
     const TAMANHO_DO_TEXTO = 40 //píxels
     const TEMPO_DE_APARIÇÃO_DO_TEXTO = 2.5



     //Aqui, criamos um registro com as informações da nave, dando o Object.freeze afim de garantir a imutabilidade dela
     const nave = Object.freeze( 
        {
          x: canv.width / 2, 
          y: canv.height / 2, //essas duas estão sendo utilizadas para fazer a nave começar do meio da tela, por meio de informações das coordenadas x e y
          raio: TAMANHO_DA_NAVE / 2, //definindo o raio ocupado pela nave
          ângulo: 90 / 180 * Math.PI, //ângulo inicial da nave, ou seja, para onde aponta a nave
          tempo_de_explosão:0, 
          rotação: 0, //a posição inicial da nave em relação ao seu próprio eixo
          impulsionando: false, //o foguete começa parado, portanto os motores estão desligados e sem impulso
          impulso: Object.freeze({
                x: 0,
                y: 0
           })  //sistema de impulso do foguete que será utilizado mais tarde

        })
     
    
//Aqui, criamos uma cópia do registro, para podermos alterar valores e, ainda assim, garantir a imutabilidade do registro original
   const novaNave = {
  ...nave,
  impulso: {...nave.impulso}
   }
   //uma função para caso a nave se choque contra um asteroide
   function Explodir_a_nave() {
            novaNave.tempo_de_explosão = Math.ceil(TEMPO_DE_EXPLOSÃO_DA_NAVE * FPS);//Math.cell seria o oposto de math.floor, ele irá arrendondar para o maior inteiro
            }

   //Aqui, realizamos os comandos e o código para os eventos do clique de teclas no teclado, para fazer a nave se movimentar pelo mapa
    const keyDown = (/** @type {KeyboardEvent} */ evento) => {  // o keycode armazena um número que representa a tecla que foi pressionada
     switch(evento.keyCode){
          case 37: //37 representa a seta para a esquerda(objetivo: rotacionar para a esquerda)
            novaNave.rotação = VELOCIDADE_DE_ROTAÇÃO / 180 * Math.PI / FPS 
            break;
          case 38: //representa a tecla para cima(objetivo: mover a nave para frente) 
           novaNave.impulsionando = true 
            break;  
          case 39: //representa a seta para a esquerda(objetivo: rotacionar para a direita)
            novaNave.rotação = -VELOCIDADE_DE_ROTAÇÃO / 180 * Math.PI / FPS
            break; 

            }  
        }
    const keyUp = (/** @type {KeyboardEvent} */evento) => {  // o keycode armazena um número que representa a tecla que foi pressionada
        switch(evento.keyCode) /**uma série de perguntas do tipo if/else*/{
          case 37: //37 representa a seta para a esquerda(objetivo: parar de rotacionar)
            novaNave.rotação = 0; 
            break;
          case 38: //representa a tecla para cima(objetivo: mover a nave para frente) 
            novaNave.impulsionando = false
            break;  
          case 39: //representa a seta para a esquerda(objetivo: parar de rotacionar)
            novaNave.rotação = 0;
            break; 
                
               
            }  
        }
        
        
     document.addEventListener("keydown", keyDown); //keydow vai identificar que alguma teclado de teclado está sendo pressionada
     document.addEventListener("keyup", keyUp);


         //Implementando a tecla que, ao pressionada, permitirá o jogo iniciar a música por intermédio de uma interação do usuário

      const iniciarMusica = () =>{
        audio.play().catch(error => {
            console.log("Erro na repordução. Clique para iniciar a música")
        })
      }

      document.addEventListener('keydown', iniciarMusica, {once:true})
     //Asteroides
     //crriando uma função que retorna um registro que contém as propriedades dos asteroides
     const asteroideXD = (x,y) => Object.freeze({
        x: x,
        y: y,
        xv: Math.random() * VELOCIDADE_DOS_ASTEROIDES / FPS * (Math.random() < 0.5? 1 : -1), //velocidade do asteroide no eixo x
        yv: Math.random() * VELOCIDADE_DOS_ASTEROIDES / FPS * (Math.random() < 0.5? 1 : -1), //velocidade do asteroide no eixo y
        raio: TAMANHO_DOS_ASTEROIDES / 2, //raio do asteroide
        ângulo: Math.random() * Math.PI * 2, //ângulo para onde o asteroide estará apontado
        vértices: Math.floor(Math.random() * (VÉRTICE_DO_ASTEROIDE + 1) + VÉRTICE_DO_ASTEROIDE / 2), //para onde os vértices(são triângulos) vão apontar
        curvaturas: 0, 
        })
    //função utilizada para calcular a distância entre dois pontos quaisquer, será utilizada para verificar se a nave bateu em algum asteroide
    function distanciaEntrePontos(x1,y1,x2,y2){
        return Math.sqrt(Math.pow(x2-x1,2) + Math.pow(y2-y1,2))
    }
    //Função para desenhar a explosão da nave
    function Explodir_a_nave_desenho(){
        contexto.fillStyle = "lime"
        contexto.strokeStyle = "lime"
        contexto.beginPath()
        contexto.arc(novaNave.x, novaNave.y, novaNave.raio,0, Math.PI * 2, false)
        contexto.fill()
        contexto.stroke()
    }
    //função para gerar uma posição aleatória para o surgimento de um asteroide
    const gerarPosicaoAleatoria = (canvas) => ({
            //meio que canvas seria minemonico como argumento arbitrario nesse caso
            //porque se refere ao canvas usado lá em cima
            x: Math.floor(Math.random() * canvas.width), //gera um x do maximo ao minimo da tela, multiplicando o valor da tela por algo netre 0 e 1
            y: Math.floor(Math.random() * canvas.height) //mesma coisa só que pra y
        })


        //como é uma posição aleatória seria complicado se surgisse direto na nave
        //então é bom definir uma distância segura calculando a distância entre os dois pontos
        const verificar_posicao_segura = (nave) => (pedra) => {
            if ((Math.sqrt((pedra.x-nave.x)**2 + (pedra.y-nave.y)**2) >= 225)) //225 ou mais é a distancia segura
            {return true}
            else {return false}
             //se cumprir os pre requisitos retorna true, se não false 
        }


        //função que gera uma posição válida usando recursão
        //canvas é minemonico pelo argumento anterior

         const gerarPosicaoValida = (nave, canvas) => {
            const posicao = gerarPosicaoAleatoria(canvas) //posicao é registro com coordenadas x e y, ele gera uma posição
            if ((verificar_posicao_segura(nave)(posicao))===true) { //testa se a posição é válida
                return posicao //se a posição na constante for segura ele retorna True e gera a posicao, assim se for válido a função acaba
            } else {
            return gerarPosicaoValida(nave, canvas) //se nao repete a funcao em busca de uma posicao valida até achar uma posição valida
            //tava dando erro sem if else e return então essas coisas foram colocadas
        }
    }



        //função para criar asteroides baseada na posição válida
        const criarAsteroide = (nave, canvas) => {
            const posicaoValida = gerarPosicaoValida(nave, canvas)
            return {...asteroideXD(posicaoValida.x,posicaoValida.y)}
        }

        const novo_asteroide2 = {...criarAsteroide(nave,canv)}
        



        //função que cria a lista de asteroides de forma recursiva
         const criarListaAsteroides = (nave, canvas, quantidade) => {
            if (quantidade <= 0) {
                return Object.freeze([])            }
            else {return Object.freeze([
                criarAsteroide(nave, canvas),
                ...criarListaAsteroides(nave, canvas, quantidade - 1)
            ])}
        }


    gerarPosicaoAleatoria(canv)
         //Criando a constante na qual o jogo irá ser focado, que realmente fará o jogo acontecer

    const lista_de_asteroide = criarListaAsteroides(nave, canv, 10)
            //utilizando o CSS para desenhar os asteroides
            const Desenho_dos_asteroides = (lista) => {  //6=quantidade
              contexto.strokeStyle = "white"
              contexto.beginPath()
              contexto.arc(lista.x,lista.y,lista.raio, 0, Math.PI * 2,false)
              contexto.stroke()
        }
        //Aqui, criamos as funções de soma e subtração para podermos trabalhar com a rotação e movimentação da nave de maneira funcional, por meio de listas
        //const soma = (lista) => lista[0] + lista[1]
        //const subtração = (lista) => lista [0] - lista[1]
        const soma = (lista) => lista[0] + lista[1]
        const subtração = (lista) => lista [0] - lista[1]



       const textogameover = "Jubilado"
       const textoreiniciar = "Aperte F5 para reiniciar"
       const textobonscaminhos = "Bons Caminhos!"
       const textoposgameover = "Teste de memória: qual sua pontuação?"
       const textoAlpha = 1.0   
    
     //uma função update para atualizar os frames do jogo e tornar possível a atualização de imagem
     const update = () => {
        //listas que serão utilizadas posteriormente para trabalhar com a movimentação da nave 
        lista_para_o_impulso_x = Object.freeze([novaNave.impulso.x, IMPULSO_DA_NAVE * Math.cos(novaNave.ângulo) / FPS])
        lista_para_o_impulso_y = Object.freeze([novaNave.impulso.y, IMPULSO_DA_NAVE * Math.sin(novaNave.ângulo) / FPS])
        lista_para_a_fricção_x = Object.freeze([novaNave.impulso.x, FRICÇÃO * novaNave.impulso.x / FPS])
        lista_para_a_fricção_y = Object.freeze([novaNave.impulso.y, FRICÇÃO * novaNave.impulso.y / FPS]) 
        //criando uma constante que, quando verdadeira, irá iniciar o processo de desenhar a explosão da nave
        const explodindo = novaNave.tempo_de_explosão > 0;
        //Desenhando o fundo do jogo
        contexto.fillStyle = "black";
        contexto.fillRect(0, 0, canv.width, canv.height)

        
         //Desenhando a nave(Em formato triângular), caso não tenha colisão, por isso o !explosion
        if(!explodindo){
            contexto.strokeStyle = "red";
            contexto.lineWidth = TAMANHO_DA_NAVE / 20,
            contexto.beginPath()
            contexto.moveTo(
              novaNave.x + 4/3 * novaNave.raio * Math.cos(novaNave.ângulo),
              novaNave.y - 4/3 * novaNave.raio * Math.sin(novaNave.ângulo)

            )
            contexto.lineTo(
              novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) + Math.sin(novaNave.ângulo)), //Traseira Esquerda da Nave
              novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) - Math.cos(novaNave.ângulo))
            )
            contexto.lineTo(
              novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) - Math.sin(novaNave.ângulo)), //Traseira Direita da Nave
              novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) + Math.cos(novaNave.ângulo))
            )    
            contexto.closePath()
            contexto.stroke()
            //Impulsionando a nave
            if (novaNave.impulsionando) {
                novaNave.impulso.x = soma(lista_para_o_impulso_x) ;
                novaNave.impulso.y = subtração(lista_para_o_impulso_y);
                
                contexto.fillStyle = "yellow"
                contexto.strokeStyle = "red" //pode ser interpretado como "escolher a cor da caneta que será utulizada para desenhar a nave"
                contexto.lineWidth = TAMANHO_DA_NAVE / 10, //define a espessura das linhas
                contexto.beginPath();  // seria basicamente "começar um novo desenho", você tira a ponta da caneta do papel e coloca em um lugar novo para começar uma nova forma
                contexto.moveTo( //foguete esquerdo
                    novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) + 0.5* Math.sin(novaNave.ângulo)), 
                    novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) - 0.5*Math.cos(novaNave.ângulo))
               ) // levantar a ponta do lápis e levar ela a um novo local
                contexto.lineTo( // foguete central atrás da nave
                    novaNave.x - novaNave.raio * (6/3 *Math.cos(novaNave.ângulo) ), //Traseira Esquerda da Nave
                    novaNave.y + novaNave.raio * (6/3 *Math.sin(novaNave.ângulo) )
               )
                contexto.lineTo( //foguete direito
                    novaNave.x - novaNave.raio * (2/3 *Math.cos(novaNave.ângulo) - 0.5*Math.sin(novaNave.ângulo)), //Traseira Direita da Nave
                    novaNave.y + novaNave.raio * (2/3 *Math.sin(novaNave.ângulo) + 0.5* Math.cos(novaNave.ângulo))
               )
                contexto.closePath()
                contexto.fill()
                contexto.stroke()

           }else {
              //aqui é para deixar sem o rastro de fogo
              //se não tiver impulsionando fica sem restro de fogo
             novaNave.impulso.x = subtração(lista_para_a_fricção_x)
             novaNave.impulso.y = subtração(lista_para_a_fricção_y)
           }
        const temporizador = (intervalo, naveEstado) => {
  const executar = (tempo) => {
    if (naveEstado===true) {
      // A nave está explodindo, parar a contagem e retornar o valor atual
      return tempo
    } else {
      // Continua a contagem
      setTimeout(() => {
        // Chamada recursiva passando o mesmo estado atualizado
        executar(tempo + 1)
      }, intervalo)
    }
  }
  return executar(0)
}
        
        const pontuacao = `Pontuação :${setInterval(temporizador(1000,explodindo),1000)}` 
        contexto.textAlign = "center"
        contexto.fillStyle = "rgba(255, 255, 255, " + textoAlpha + ")"
        contexto.font = "small-caps " + TAMANHO_DO_TEXTO  + "px dejavu sans mono"
        contexto.fillText(pontuacao, canv.width / 2, canv.height * 0.1)

        
         }//caso tenha a colisão, desenharemos a explosão
          else{
            contexto.fillStyle = "red"
            contexto.beginPath()
            contexto.arc(novaNave.x,novaNave.y,novaNave.raio * 1.7, 0, Math.PI * 2,false)
            contexto.fill()
            
            contexto.fillStyle = "orange"
            contexto.beginPath()
            contexto.arc(novaNave.x,novaNave.y,novaNave.raio * 1.1, 0, Math.PI * 2,false)
            contexto.fill()
            
            contexto.fillStyle = "yellow"
            contexto.beginPath()
            contexto.arc(novaNave.x,novaNave.y,novaNave.raio * 0.8, 0, Math.PI * 2,false)
            contexto.fill()
            
            contexto.fillStyle = "white"
            contexto.beginPath()
            contexto.arc(novaNave.x,novaNave.y,novaNave.raio * 0.5, 0, Math.PI * 2,false)
            contexto.fill()


            contexto.textAlign = "center"
              contexto.fillStyle = "rgba(255, 255, 255, " + textoAlpha + ")"
              contexto.font = "small-caps " + TAMANHO_DO_TEXTO  + "px dejavu sans mono"
              contexto.fillText(textoreiniciar, canv.width / 2, canv.height * 0.75)
              //textoAlpha = textoAlpha - 1.0 / TEMPO_DE_APARIÇÃO_DO_TEXTO / FPS

            contexto.textAlign = "center"
              contexto.fillStyle = "rgba(255, 255, 255, " + textoAlpha + ")"
              contexto.font = "small-caps " + TAMANHO_DO_TEXTO  + "px dejavu sans mono"
              contexto.fillText(textobonscaminhos, canv.width / 2, canv.height * 0.9)

            contexto.textAlign = "center"
              contexto.fillStyle = "rgba(255, 255, 255, " + textoAlpha + ")"
              contexto.font = "small-caps " + TAMANHO_DO_TEXTO  + "px dejavu sans mono"
              contexto.fillText(textogameover, canv.width / 2, canv.height * 0.1)

              contexto.textAlign = "center"
              contexto.fillStyle = "rgba(255, 255, 255, " + textoAlpha + ")"
              contexto.font = "small-caps " + TAMANHO_DO_TEXTO  + "px dejavu sans mono"
              contexto.fillText(textoposgameover, canv.width / 2, canv.height * 0.25)

             return setInterval(update, 0)
          

         } 
        //Centro do Triângulo(será usado um ponto para marcar o centro)
        contexto.fillStyle = "red"
        contexto.fillRect(novaNave.x - 1, novaNave.y - 1, 2,2) 

        
        //Rotacionando a nave
        
        lista_ângulo_e_rotação = Object.freeze([novaNave.ângulo,novaNave.rotação])
        

        novaNave.ângulo = soma(lista_ângulo_e_rotação)


        //Movendo a nave
        lista_x_e_impulso= Object([novaNave.x,novaNave.impulso.x])
        lista_y_e_impulso = Object.freeze([novaNave.y,novaNave.impulso.y])

        novaNave.x = soma(lista_x_e_impulso)
        novaNave.y = soma(lista_y_e_impulso)

           //Limitando tela, impedindo a nave de sumir, fazendo ela reaparecer nos outros lados
          if (novaNave.x < 0 - novaNave.raio) {
              novaNave.x = canv.width + novaNave.raio;
          } else if (novaNave.x > canv.width + novaNave.raio) {
              novaNave.x = 0 - novaNave.raio 
         }
         if (novaNave.y < 0 - novaNave.raio) {
              novaNave.y = canv.height + novaNave.raio
          } else if (novaNave.y > canv.height + novaNave.raio) {
            novaNave.y = 0 - novaNave.raio 
          }
  

        //Criando a movimentação dos asteroides
        if(!explodindo){
            [...lista_de_asteroide].forEach(x => {
            const lista_para_movimento_do_asteroides_x = Object.freeze([x.x,x.xv])
            const lista_para_movimento_do_asteroides_y = Object.freeze([x.y,x.yv])

            x.x = soma(lista_para_movimento_do_asteroides_x)
            x.y = soma(lista_para_movimento_do_asteroides_y)
            Desenho_dos_asteroides(x)
                   //Limitando tela, impedindo a nave de sumir, fazendo ela reaparecer nos outros lados
             if (x.x < 0 - x.raio) {
               x.x = canv.width + x.raio;
            } else if (x.x > canv.width + x.raio) {
               x.x = 0 - x.raio 
            }
             if (x.y < 0 - x.raio) {
               x.y = canv.height + x.raio
            } else if (x.y > canv.height + x.raio) {
            x.y = 0 - x.raio 
            }
             if (distanciaEntrePontos(novaNave.x,novaNave.y,x.x,x.y) < novaNave.raio +  x.raio){
               Explodir_a_nave()}
             if (MOSTRAR_COLISÃO){
                    contexto.strokeStyle = "lime"
                    contexto.beginPath()
                    contexto.arc(novaNave.x,novaNave.y,novaNave.raio, 0, Math.PI * 2,false)
                    contexto.stroke()
                }
            }) 
        } else{
            novaNave.x = canv.width / 2
            novaNave.y = canv.height / 2 //essas duas estão sendo utilizadas para fazer a nave começar do meio da tela, por meio de informações das coordenadas x e y
            novaNave.raio = TAMANHO_DA_NAVE / 2
            novaNave.ângulo = 90 / 180 * Math.PI
            novaNave.tempo_de_explosão = 0 // converte para radianos 
            novaNave.rotação = 0
            novaNave.impulsionando = false
            novaNave.impulso.x = 0 
            novaNave.impulso.y = 0     
         }
            
            
        
        }


          
    //Irá executar a função update em um intervalo de 1000/FPS  milissegundos, fazendo com que o jogo ocorra
    setInterval(update, 1000 / FPS);

        
        
    </script>
</body>

</html> 

